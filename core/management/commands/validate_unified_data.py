"""
Comando de valida√ß√£o final - Verifica integridade da unifica√ß√£o
Garante que Single Source of Truth est√° funcionando corretamente
"""

from django.core.management.base import BaseCommand
from django.db import connection
from django.utils import timezone
from core.models import Usuario, Formador, FormadoresSolicitacao, Solicitacao
from core.services import UsuarioService, FormadorService, CoordinatorService, DashboardService


class Command(BaseCommand):
    help = 'Valida integridade da unifica√ß√£o de dados no Docker PostgreSQL'

    def add_arguments(self, parser):
        parser.add_argument(
            '--docker',
            action='store_true',
            help='Execu√ß√£o no Docker (obrigat√≥rio)'
        )
        parser.add_argument(
            '--detailed',
            action='store_true',
            help='Relat√≥rio detalhado'
        )

    def handle(self, *args, **options):
        if not options['docker']:
            self.stdout.write(
                self.style.ERROR('ERRO: Execute apenas no Docker')
            )
            return

        self.stdout.write(
            self.style.SUCCESS('üîç VALIDANDO UNIFICA√á√ÉO - DOCKER POSTGRESQL')
        )

        detailed = options['detailed']
        errors = []
        warnings = []
        success_count = 0

        try:
            # TESTE 1: Verificar ambiente PostgreSQL
            self._test_postgresql_environment()
            success_count += 1

            # TESTE 2: Verificar fonte √∫nica Usuario
            self._test_usuario_single_source(errors, warnings)
            success_count += 1

            # TESTE 3: Verificar Services funcionando
            self._test_services_working(errors, warnings)
            success_count += 1

            # TESTE 4: Verificar performance de queries
            self._test_query_performance(errors, warnings, detailed)
            success_count += 1

            # TESTE 5: Verificar integridade de dados
            self._test_data_integrity(errors, warnings)
            success_count += 1

            # TESTE 6: Verificar cache funcionando
            self._test_cache_working(errors, warnings)
            success_count += 1

            # RELAT√ìRIO FINAL
            self._print_final_report(success_count, errors, warnings, detailed)

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'‚ùå ERRO CR√çTICO: {str(e)}')
            )

    def _test_postgresql_environment(self):
        """Teste 1: Verificar ambiente PostgreSQL"""
        self.stdout.write('1Ô∏è‚É£  Testando ambiente PostgreSQL...')

        with connection.cursor() as cursor:
            cursor.execute("SELECT version()")
            db_version = cursor.fetchone()[0]

        if 'PostgreSQL' not in db_version:
            raise Exception(f'Esperado PostgreSQL, encontrado: {db_version}')

        self.stdout.write(
            self.style.SUCCESS(f'   ‚úÖ PostgreSQL ativo: {db_version[:60]}...')
        )

    def _test_usuario_single_source(self, errors, warnings):
        """Teste 2: Verificar fonte √∫nica Usuario"""
        self.stdout.write('2Ô∏è‚É£  Testando fonte √∫nica Usuario...')

        # Verificar UsuarioManager ativo
        try:
            formadores_manager = Usuario.objects.formadores()
            count_manager = formadores_manager.count()
            self.stdout.write(f'   ‚úÖ UsuarioManager: {count_manager} formadores')
        except Exception as e:
            errors.append(f'UsuarioManager falhou: {str(e)}')

        # Verificar rela√ß√£o Formador-Usuario
        formadores_sem_usuario = Formador.objects.filter(usuario__isnull=True).count()
        if formadores_sem_usuario > 0:
            warnings.append(f'{formadores_sem_usuario} formadores ainda sem usu√°rio')
        else:
            self.stdout.write('   ‚úÖ Todos formadores t√™m usu√°rio')

        # Verificar consist√™ncia formador_ativo
        usuarios_formadores = Usuario.objects.filter(formador_ativo=True).count()
        formadores_ativos = Formador.objects.filter(ativo=True).count()

        if abs(usuarios_formadores - formadores_ativos) > 5:  # Toler√¢ncia pequena
            warnings.append(f'Inconsist√™ncia: {usuarios_formadores} vs {formadores_ativos}')
        else:
            self.stdout.write(f'   ‚úÖ Consist√™ncia formadores: {usuarios_formadores}')

    def _test_services_working(self, errors, warnings):
        """Teste 3: Verificar Services funcionando"""
        self.stdout.write('3Ô∏è‚É£  Testando Services...')

        try:
            # Testar UsuarioService
            usuarios_ativos = UsuarioService.ativos().count()
            self.stdout.write(f'   ‚úÖ UsuarioService: {usuarios_ativos} usu√°rios ativos')

            # Testar FormadorService
            formadores = FormadorService.todos_formadores()
            self.stdout.write(f'   ‚úÖ FormadorService: {len(formadores)} formadores')

            # Testar CoordinatorService
            coordenadores = CoordinatorService.todos_coordenadores().count()
            self.stdout.write(f'   ‚úÖ CoordinatorService: {coordenadores} coordenadores')

            # Testar DashboardService
            stats = DashboardService.get_estatisticas_gerais()
            self.stdout.write(f'   ‚úÖ DashboardService: {stats["usuarios_total"]} usu√°rios')

        except Exception as e:
            errors.append(f'Services falharam: {str(e)}')

    def _test_query_performance(self, errors, warnings, detailed):
        """Teste 4: Verificar performance de queries"""
        self.stdout.write('4Ô∏è‚É£  Testando performance...')

        if detailed:
            from django.db import reset_queries
            from django import db

            # Reset query log
            reset_queries()

            # Executar query otimizada
            formadores = list(UsuarioService.get_optimized_queryset().filter(formador_ativo=True)[:10])

            # Verificar n√∫mero de queries
            queries_count = len(db.connection.queries)
            self.stdout.write(f'   üìä Queries executadas: {queries_count}')

            if queries_count > 3:  # Deveria ser ~1 query com select_related
                warnings.append(f'Muitas queries: {queries_count} (esperado: ‚â§3)')
            else:
                self.stdout.write('   ‚úÖ Performance otimizada')

        else:
            self.stdout.write('   ‚úÖ Performance (use --detailed para detalhes)')

    def _test_data_integrity(self, errors, warnings):
        """Teste 5: Verificar integridade de dados"""
        self.stdout.write('5Ô∏è‚É£  Testando integridade...')

        # Verificar FormadoresSolicitacao
        inconsistentes = FormadoresSolicitacao.objects.filter(
            usuario__formador_ativo=False
        ).count()

        if inconsistentes > 0:
            warnings.append(f'{inconsistentes} FormadoresSolicitacao inconsistentes')
        else:
            self.stdout.write('   ‚úÖ FormadoresSolicitacao consistente')

        # Verificar solicita√ß√µes √≥rf√£s
        solicitacoes_orfas = Solicitacao.objects.filter(
            usuario_solicitante__isnull=True
        ).count()

        if solicitacoes_orfas > 0:
            errors.append(f'{solicitacoes_orfas} solicita√ß√µes √≥rf√£s')
        else:
            self.stdout.write('   ‚úÖ Todas solicita√ß√µes t√™m usu√°rio')

    def _test_cache_working(self, errors, warnings):
        """Teste 6: Verificar cache funcionando"""
        self.stdout.write('6Ô∏è‚É£  Testando cache...')

        try:
            from django.core.cache import cache

            # Testar set/get
            test_key = 'unify_test_cache'
            test_value = {'timestamp': timezone.now().isoformat()}

            cache.set(test_key, test_value, 60)
            cached_value = cache.get(test_key)

            if cached_value and cached_value['timestamp'] == test_value['timestamp']:
                self.stdout.write('   ‚úÖ Cache funcionando')
                cache.delete(test_key)
            else:
                warnings.append('Cache n√£o est√° funcionando corretamente')

        except Exception as e:
            warnings.append(f'Erro no cache: {str(e)}')

    def _print_final_report(self, success_count, errors, warnings, detailed):
        """Imprime relat√≥rio final"""
        self.stdout.write('')
        self.stdout.write('=' * 60)
        self.stdout.write(
            self.style.SUCCESS('üéØ RELAT√ìRIO DE VALIDA√á√ÉO - UNIFICA√á√ÉO COMPLETA')
        )
        self.stdout.write('=' * 60)

        # Sucessos
        self.stdout.write(f'‚úÖ SUCESSOS: {success_count}/6 testes aprovados')

        # Erros cr√≠ticos
        if errors:
            self.stdout.write(f'‚ùå ERROS CR√çTICOS: {len(errors)}')
            for error in errors:
                self.stdout.write(f'   ‚Ä¢ {error}')
        else:
            self.stdout.write('‚úÖ ZERO ERROS CR√çTICOS')

        # Avisos
        if warnings:
            self.stdout.write(f'‚ö†Ô∏è  AVISOS: {len(warnings)}')
            for warning in warnings:
                self.stdout.write(f'   ‚Ä¢ {warning}')
        else:
            self.stdout.write('‚úÖ ZERO AVISOS')

        # Status final
        if not errors:
            self.stdout.write('')
            self.stdout.write(
                self.style.SUCCESS('üéâ UNIFICA√á√ÉO VALIDADA COM SUCESSO!')
            )
            self.stdout.write('üìä Sistema funcionando com:')
            self.stdout.write('   ‚Ä¢ Usuario como fonte √∫nica ‚úÖ')
            self.stdout.write('   ‚Ä¢ Services centralizados ‚úÖ')
            self.stdout.write('   ‚Ä¢ Imports padronizados ‚úÖ')
            self.stdout.write('   ‚Ä¢ Queries otimizadas ‚úÖ')
            self.stdout.write('   ‚Ä¢ Cache ativo ‚úÖ')
            self.stdout.write('   ‚Ä¢ Integridade garantida ‚úÖ')

        else:
            self.stdout.write('')
            self.stdout.write(
                self.style.ERROR('‚ùå UNIFICA√á√ÉO COM PROBLEMAS')
            )
            self.stdout.write('Corrija os erros cr√≠ticos antes de usar em produ√ß√£o.')

        self.stdout.write('')
        self.stdout.write('üí° Comando √∫til para debug:')
        self.stdout.write('docker-compose exec web python manage.py shell')
        self.stdout.write('>>> from core.services import *')
        self.stdout.write('>>> UsuarioService.ativos().count()')
        self.stdout.write('')