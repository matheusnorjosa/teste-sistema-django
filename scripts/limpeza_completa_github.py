#!/usr/bin/env python3
"""
Limpeza Completa do Reposit√≥rio GitHub
=====================================

Script para executar limpeza completa baseada na an√°lise detalhada
de todos os arquivos do reposit√≥rio GitHub.

Author: Claude Code
Date: Janeiro 2025
"""

import os
import json
import shutil
from pathlib import Path
from datetime import datetime

class GitHubCleaner:
    """Limpeza completa do reposit√≥rio GitHub"""
    
    def __init__(self, root_path=".", analysis_file=None):
        self.root_path = Path(root_path)
        self.analysis = None
        self.operations = {
            "files_removed": [],
            "files_moved": [],
            "directories_cleaned": [],
            "gitignore_updated": [],
            "errors": []
        }
        
        if analysis_file:
            self.load_analysis(analysis_file)
    
    def load_analysis(self, analysis_file):
        """Carrega an√°lise do arquivo JSON"""
        try:
            with open(analysis_file, 'r', encoding='utf-8') as f:
                self.analysis = json.load(f)
            print(f"‚úÖ An√°lise carregada de: {analysis_file}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao carregar an√°lise: {e}")
            return False
    
    def remove_unnecessary_files(self):
        """Remove arquivos desnecess√°rios"""
        if not self.analysis:
            print("‚ùå An√°lise n√£o carregada!")
            return False
        
        print("üóëÔ∏è Removendo arquivos desnecess√°rios...")
        
        files_to_remove = self.analysis["recommendations"]["files_to_remove"]
        
        for file_info in files_to_remove:
            file_path = self.root_path / file_info["file"]
            
            try:
                if file_path.exists():
                    # Fazer backup antes de remover
                    backup_path = self.root_path / "backups" / "removed_files" / file_info["file"]
                    backup_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(file_path, backup_path)
                    
                    # Remover arquivo
                    file_path.unlink()
                    
                    self.operations["files_removed"].append({
                        "file": str(file_path),
                        "reason": file_info["reason"],
                        "size_mb": file_info["size_mb"],
                        "backup": str(backup_path)
                    })
                    
                    print(f"‚úÖ Removido: {file_path} (backup: {backup_path})")
                else:
                    print(f"‚ö†Ô∏è Arquivo n√£o encontrado: {file_path}")
                    
            except Exception as e:
                error_msg = f"Erro ao remover {file_path}: {e}"
                self.operations["errors"].append(error_msg)
                print(f"‚ùå {error_msg}")
        
        return True
    
    def organize_files(self):
        """Organiza arquivos em estrutura adequada"""
        print("üìÅ Organizando arquivos...")
        
        # Criar diret√≥rios de organiza√ß√£o
        organize_dirs = {
            "scripts": self.root_path / "scripts",
            "reports": self.root_path / "reports",
            "data": self.root_path / "data",
            "backups": self.root_path / "backups",
            "temp": self.root_path / "temp"
        }
        
        for dir_name, dir_path in organize_dirs.items():
            dir_path.mkdir(exist_ok=True)
            print(f"üìÇ Diret√≥rio criado/verificado: {dir_path}")
        
        # Organizar scripts
        scripts_patterns = [
            "analise_*.py",
            "limpeza_*.py",
            "extrair_*.py",
            "import_*.py",
            "test_*.py",
            "debug_*.py"
        ]
        
        for pattern in scripts_patterns:
            for file_path in self.root_path.glob(pattern):
                if file_path.is_file():
                    try:
                        dest_path = organize_dirs["scripts"] / file_path.name
                        if not dest_path.exists():
                            shutil.move(str(file_path), str(dest_path))
                            self.operations["files_moved"].append({
                                "from": str(file_path),
                                "to": str(dest_path),
                                "reason": "Organiza√ß√£o de scripts"
                            })
                            print(f"üìÅ Movido: {file_path} -> {dest_path}")
                    except Exception as e:
                        error_msg = f"Erro ao mover {file_path}: {e}"
                        self.operations["errors"].append(error_msg)
                        print(f"‚ùå {error_msg}")
        
        # Organizar relat√≥rios
        reports_patterns = [
            "RELATORIO_*.md",
            "relatorio_*.json",
            "analise_*.json",
            "ANALISE_*.md"
        ]
        
        for pattern in reports_patterns:
            for file_path in self.root_path.glob(pattern):
                if file_path.is_file():
                    try:
                        dest_path = organize_dirs["reports"] / file_path.name
                        if not dest_path.exists():
                            shutil.move(str(file_path), str(dest_path))
                            self.operations["files_moved"].append({
                                "from": str(file_path),
                                "to": str(dest_path),
                                "reason": "Organiza√ß√£o de relat√≥rios"
                            })
                            print(f"üìÅ Movido: {file_path} -> {dest_path}")
                    except Exception as e:
                        error_msg = f"Erro ao mover {file_path}: {e}"
                        self.operations["errors"].append(error_msg)
                        print(f"‚ùå {error_msg}")
        
        return True
    
    def update_gitignore(self):
        """Atualiza arquivo .gitignore"""
        print("üìù Atualizando .gitignore...")
        
        if not self.analysis:
            print("‚ùå An√°lise n√£o carregada!")
            return False
        
        gitignore_path = self.root_path / ".gitignore"
        gitignore_patterns = self.analysis["recommendations"]["files_to_add_gitignore"]
        
        # Ler .gitignore atual
        current_patterns = set()
        if gitignore_path.exists():
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                current_patterns = set(line.strip() for line in f if line.strip() and not line.startswith('#'))
        
        # Adicionar novos padr√µes
        new_patterns = set()
        for pattern_info in gitignore_patterns:
            pattern = pattern_info["pattern"]
            if pattern not in current_patterns:
                new_patterns.add(pattern)
        
        # Escrever .gitignore atualizado
        if new_patterns:
            with open(gitignore_path, 'a', encoding='utf-8') as f:
                f.write("\n# Padr√µes adicionados automaticamente\n")
                for pattern in sorted(new_patterns):
                    f.write(f"{pattern}\n")
                    self.operations["gitignore_updated"].append(pattern)
                    print(f"‚úÖ Adicionado ao .gitignore: {pattern}")
        
        return True
    
    def clean_directories(self):
        """Limpa diret√≥rios desnecess√°rios"""
        print("üßπ Limpando diret√≥rios...")
        
        if not self.analysis:
            print("‚ùå An√°lise n√£o carregada!")
            return False
        
        directories_to_clean = self.analysis["recommendations"]["directories_to_clean"]
        
        for dir_info in directories_to_clean:
            dir_path = self.root_path / dir_info["directory"]
            
            try:
                if dir_path.exists() and dir_path.is_dir():
                    # Fazer backup do diret√≥rio
                    backup_path = self.root_path / "backups" / "removed_directories" / dir_info["directory"]
                    backup_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copytree(dir_path, backup_path)
                    
                    # Remover diret√≥rio
                    shutil.rmtree(dir_path)
                    
                    self.operations["directories_cleaned"].append({
                        "directory": str(dir_path),
                        "reason": dir_info["reason"],
                        "backup": str(backup_path)
                    })
                    
                    print(f"‚úÖ Diret√≥rio removido: {dir_path} (backup: {backup_path})")
                else:
                    print(f"‚ö†Ô∏è Diret√≥rio n√£o encontrado: {dir_path}")
                    
            except Exception as e:
                error_msg = f"Erro ao remover diret√≥rio {dir_path}: {e}"
                self.operations["errors"].append(error_msg)
                print(f"‚ùå {error_msg}")
        
        return True
    
    def create_organized_structure(self):
        """Cria estrutura organizada"""
        print("üèóÔ∏è Criando estrutura organizada...")
        
        # Estrutura proposta
        structure = {
            "scripts": {
                "extraction": "Scripts de extra√ß√£o de dados",
                "oauth": "Scripts de autentica√ß√£o OAuth",
                "verification": "Scripts de verifica√ß√£o",
                "test": "Scripts de teste",
                "optimized": "Scripts otimizados"
            },
            "reports": {
                "analysis": "Relat√≥rios de an√°lise",
                "migration": "Relat√≥rios de migra√ß√£o",
                "cleanup": "Relat√≥rios de limpeza"
            },
            "data": {
                "extracted": "Dados extra√≠dos",
                "backups": "Backups de dados",
                "exports": "Exporta√ß√µes"
            },
            "docs": {
                "technical": "Documenta√ß√£o t√©cnica",
                "user": "Documenta√ß√£o do usu√°rio",
                "api": "Documenta√ß√£o da API"
            }
        }
        
        for main_dir, subdirs in structure.items():
            main_path = self.root_path / main_dir
            main_path.mkdir(exist_ok=True)
            
            for sub_dir, description in subdirs.items():
                sub_path = main_path / sub_dir
                sub_path.mkdir(exist_ok=True)
                
                # Criar README com descri√ß√£o
                readme_path = sub_path / "README.md"
                if not readme_path.exists():
                    with open(readme_path, 'w', encoding='utf-8') as f:
                        f.write(f"# {sub_dir.title()}\n\n{description}\n")
                
                print(f"üìÇ Criado: {sub_path}")
        
        return True
    
    def execute_cleanup(self):
        """Executa limpeza completa"""
        print("üßπ Iniciando limpeza completa do reposit√≥rio GitHub...")
        print("=" * 70)
        
        if not self.analysis:
            print("‚ùå An√°lise n√£o carregada! Execute primeiro a an√°lise.")
            return False
        
        # Executar opera√ß√µes de limpeza
        print("üóëÔ∏è Fase 1: Removendo arquivos desnecess√°rios...")
        self.remove_unnecessary_files()
        
        print("\nüìÅ Fase 2: Organizando arquivos...")
        self.organize_files()
        
        print("\nüìù Fase 3: Atualizando .gitignore...")
        self.update_gitignore()
        
        print("\nüßπ Fase 4: Limpando diret√≥rios...")
        self.clean_directories()
        
        print("\nüèóÔ∏è Fase 5: Criando estrutura organizada...")
        self.create_organized_structure()
        
        return True
    
    def generate_cleanup_report(self):
        """Gera relat√≥rio de limpeza"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"relatorio_limpeza_completa_github_{timestamp}.json"
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "operations": self.operations,
            "summary": {
                "files_removed": len(self.operations["files_removed"]),
                "files_moved": len(self.operations["files_moved"]),
                "directories_cleaned": len(self.operations["directories_cleaned"]),
                "gitignore_patterns_added": len(self.operations["gitignore_updated"]),
                "errors": len(self.operations["errors"])
            }
        }
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"üìä Relat√≥rio de limpeza salvo em: {report_file}")
        return report_file
    
    def print_summary(self):
        """Imprime resumo da limpeza"""
        print("\nüìä RESUMO DA LIMPEZA COMPLETA:")
        print("=" * 50)
        print(f"üóëÔ∏è Arquivos removidos: {len(self.operations['files_removed'])}")
        print(f"üìÅ Arquivos movidos: {len(self.operations['files_moved'])}")
        print(f"üßπ Diret√≥rios limpos: {len(self.operations['directories_cleaned'])}")
        print(f"üìù Padr√µes .gitignore adicionados: {len(self.operations['gitignore_updated'])}")
        print(f"‚ùå Erros encontrados: {len(self.operations['errors'])}")
        
        if self.operations["errors"]:
            print("\n‚ùå ERROS ENCONTRADOS:")
            for error in self.operations["errors"]:
                print(f"  ‚Ä¢ {error}")

def main():
    """Fun√ß√£o principal"""
    print("üßπ Limpeza Completa do Reposit√≥rio GitHub - Sistema Aprender")
    print("=" * 70)
    
    # Encontrar arquivo de an√°lise mais recente
    analysis_files = list(Path(".").glob("relatorio_analise_completa_github_*.json"))
    if not analysis_files:
        print("‚ùå Nenhum arquivo de an√°lise encontrado!")
        print("Execute primeiro: python analise_completa_github.py")
        return
    
    latest_analysis = max(analysis_files, key=lambda x: x.stat().st_mtime)
    print(f"üìä Usando an√°lise: {latest_analysis}")
    
    # Executar limpeza
    cleaner = GitHubCleaner(analysis_file=latest_analysis)
    
    if cleaner.execute_cleanup():
        # Gerar relat√≥rio
        report_file = cleaner.generate_cleanup_report()
        
        # Mostrar resumo
        cleaner.print_summary()
        
        print(f"\nüìÑ Relat√≥rio completo salvo em: {report_file}")
        print("\n‚úÖ Limpeza completa conclu√≠da!")
    else:
        print("\n‚ùå Erro durante a limpeza!")

if __name__ == "__main__":
    main()
